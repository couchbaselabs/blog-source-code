[{"appcode":"/* \nFunction \"cron_impl_2func_660\" single function implemention\n\nCreate a basic cron system using Eventing allows a recurring function to execute activity\nat a specified time every day, hour, min, 30 sec., and 15 sec.  We use a bucket called\n'crondata' aliased to 'cron_bkt' which can hold one or more schduler control documents of \ntype = \"recurring_event\".\n\nThe following uses of timers as of Couchbase 6.6.0 now work reliably\n  a) scheduling an Eventing timer within a timer's callback \n  b) overwriting an existing timer by id\n  \nFor this example, we supply one real user function that builds a recurring 'static' cache\ndocument from bucket `travel-sample` via an N1QL query and save the result back to \n`travel-sample` via the alais 'ts_bkt'.  This JavaScript function is doCronActionA(), we\nalso provide two placeholders doCronActionB() and doCronActionC() for some additional\nexperimentation.\n\nTest Doc:\n   {\n        \"type\":\"recurring_event\",   // The KEY will be <<type>>::<<id>>\n        \"id\":1,                     //\n        \"hour\":14,                  // The hour of the day 0-23, *, *2X, *4X to trigger\n        \"min\":54,                   // The minute in the hour 0-59, *, *2X, *4X to trigger\n        \"action\":\"doCronActionA\",   // What function to run on the trigger\n        \"active\":false,             // Flag to arm or disable this schedule\n        \"verbose\" : {\n          \"user_func\":2,            // Logging level for the action logic : 0=none, etc. etc.\n          \"scheduler\":3             // Logging level for the cron logic   : 0=none, etc. etc.\n        },\n        \"dynamic\" : {\n          \"state\":\"arm\",            // States \"arm\"|\"rearm\"|\"pending\" if any value but \"pending\" start a schedule\n          \"next_sched\": 0,          // Number of seconds since epoch to next desired schedule\n          \"prev_sched\": 0,          // Number of seconds since epoch for previous schedule\n          \"prev_etime\": 0,          // Number of seconds since epoch for previous schedule actual exec time\n          \"prev_delay\": 0,          // Number of seconds that the timer was delayed from the schedule\n          \"prev_atime\": 0,          // Number of seconds taken by the user 'action'\n          \"total_runs\": 0           // Number of times the scheule has been invoked with this schedule\n        }\n    }\n    \n    INSERT INTO `crondata` (KEY,VALUE) VALUES (\"recurring_event::1\", \n    {\n        \"type\":\"recurring_event\",\n        \"id\":1,\n        \"hour\":14,\n        \"min\":54,\n        \"action\":\"doCronActionA\",\n    \t\"verbose\" : {\n          \"user_func\":2,\n          \"scheduler\":3\n        },\n        \"active\":false,\n\t    \"dynamic\" : {\n          \"state\": \"arm\",\n          \"next_sched\": 0,\n          \"prev_sched\": 0,\n          \"prev_etime\": 0,\n          \"prev_delay\": 0,\n          \"prev_atime\": 0,\n          \"total_runs\": 0\n\t    }\n    } \n    );\n\nNote, you can omit verbose{} and dynamic{} as they will be auto-created by this main Eventing \nFunction \"cron_impl_2func_651\". If verbose{} is missing the logging levels will default to \nverbose\" : {  \"user_func\":1, \"scheduler\":1 }\n\n    INSERT INTO `crondata` (KEY,VALUE) VALUES (\"recurring_event::1\", \n    {\n        \"type\":\"recurring_event\",\n        \"id\":1,\n        \"hour\":14,\n        \"min\":54,\n        \"action\":\"doCronActionA\",\n        \"active\":false\n    } \n    );\n\nN1QL : Make an index to query data without specifying keys\n    CREATE primary INDEX on `crondata` ;\n\nN1QL : Verify or inspect settings in schedule\t        \n    SELECT * FROM `crondata` WHERE type=\"recurring_event\";\n\nN1QL : Arm or set active\t    \n    UPDATE `crondata` SET active = true WHERE type=\"recurring_event\" AND id=1 ;\n    \nN1QL : Disarm or set inactive\t\n    UPDATE `crondata` SET active = false WHERE type=\"recurring_event\" AND id=1 ;\n    \nN1QL : Adjust time of trigger\t\n    UPDATE `crondata` SET hour = 11, min = 30 WHERE type=\"recurring_event\" AND id=1 ;\n\nN1QL : Adjust logging\t        \n    UPDATE `crondata` SET verbose.user_func = 1,  verbose.scheduler = 0 WHERE type=\"recurring_event\" AND id=1 ;\n\nN1QL : Delete the schedule\t    \n    DELETE FROM `crondata` WHERE type=\"recurring_event\" AND id=1 ;\n         \nThe action field is important it 'should' exist in this Eventing Function note it could be any \nJavaScript name e.g. MyFunc and you must implement like the example doCronActionA(doc) where\ndoc will be the currently active item of type = 'recurring_event' read from the alias bucket\n‘cron_bkt’ when the timer is fired.  The action JavaScript function should return  either true\nor false used for logging purposes.  If the action does not exist it is an error and a warning\nis logged and the timer is disabled.\n\nIn Couchbase version 6.6+ to add a new cron like daily function just pause the active handler \ninsert your new function doCronActionB(doc) {...} then Resume the eventing handler.  The nice \nthing is if a timer was to be fired will the function was paused it will NOT be lost, when you \nresume the function it will be processed at the next available scan time looking for active\ntimers, i.e as soon a possible.  \n\nAny change to a control structure will create a new recurring schedule or timer and cancel the \ncurrent previous schedule this includes changing the verbosity level. To prevent any possible \nrace between a schedule adjustment we do a Checksum on the current control structure from KV\nagainst it’s passed context and if different the Callback will ignore the old schedule.\n*/\n\n// ==================\n/* BEG USER FUNCTIONS TO RUN ONCE A DAY, HOUR, OR MINUTE - ANYTHING YOU WANT BELOW */\nfunction doCronActionA(doc) {\n  try {\n    // Check that doc has desired values\n    if (!doc.type || doc.type !== \"recurring_event\") return;\n    // On any mutation always cancel any existing timer\n    try { cancelTimer(meta.id); } catch (e) { }\n    // if not active do nothing i.e. return\n    if (!doc.active || doc.active !== true) return;\n    \n    if (doc.verbose.user_func >= 1)\n      log(doc.action + ' user action controlled by ' + doc.type + '::' + doc.id);\n\n    // this is a 6.5 N1QL query (feature not available in GA prior to 6.5)\n    // Create an embedded N1QL iterator by issuing a SELECT statement to get the\n    // counts of airlines by country.  Make a new document and write it out to KV \n\n    // We will use the iterator to create a KV document representing the results of a\n    // HARD lengthy embedded N1QL query and write it back to KV, the idea is to keep\n    // a calculation up to date once a day such that it that can be read 'quickly' \n    // by other Eventing Functions, other Couchbase services or SDKs.   \n\n    // Consider if we had 1 million docs in a minute do we really want to use N1QL\n    // to recalculate something that is almost static for all 1 million documents, of \n    // course not, so we make an intermediate value that can be read into Eventing\n    // and used via a single 'light weight' KV read.\n\n    var q_iter = SELECT country,\n      count( * ) cnt\n    FROM `travel-sample`\n    WHERE `type` = 'airline'\n    GROUP BY country;\n\n    // loop through the result set and update the map 'accumulate'\n    var accumulate = {};\n    var idx = 0;\n    for (var val of q_iter) {\n      if (doc.verbose.user_func >= 2)\n        log(doc.action + ' N1QL idx ' + idx + ', country ' + val.country + \" cnt \" + val.cnt);\n      accumulate[val.country] = val.cnt;\n      idx++;\n    }\n    // close out embedded N1QL iterator\n    q_iter.close();\n\n    // Now let’s make a cached KV document representing a HARD length embedded N1QL\n    // query and write it back to KV, we need a KEY and a type and id and then we \n    // upsert it into the `travel-sample` bucket.\n\n    var cachedoc = {};\n    cachedoc.type = \"cron_cache\";\n    cachedoc.id = \"airlines_by_country\";\n    cachedoc.date = new Date();\n    cachedoc.data = accumulate;\n    var ckey = cachedoc.type + '::' + cachedoc.id;\n    ts_bkt[ckey] = cachedoc;\n    if (doc.verbose.user_func >= 2) {\n      log(doc.action + ' upsert to KV with KEY ' + ckey + ' cachedoc ', cachedoc);\n    }\n  } catch (e) {\n    log(doc.action + ' Error exception:', e);\n    return false;\n  }\n  return true;\n}\n\nfunction doCronActionB(doc) {\n  try {\n    // check that doc has desired values\n    if (doc.type !== \"recurring_event\" || doc.active !== true) return;\n    if (doc.verbose.user_func >= 1)\n      log(doc.action + ' user action controlled by ' + doc.type + '::' + doc.id);\n\n    // YOUR LOGIC HERE\n    \n  } catch (e) {\n    log(doc.action + ' Error exception:', e);\n    return false;\n  }\n  return true;\n}\n\nfunction doCronActionC(doc) {\n  try {\n    // check that doc has desired values\n    if (doc.type !== \"recurring_event\" || doc.active !== true) return;\n    if (doc.verbose.user_func >= 1)\n      log(doc.action + ' user action controlled by ' + doc.type + '::' + doc.id);\n\n    // YOUR LOGIC HERE\n\n  } catch (e) {\n    log(doc.action + ' Error exception:', e);\n    return false;\n  }\n  return true;\n}\n\n/* END USER FUNCTIONS TO RUN ONCE A DAY, HOUR, OR MINUTE - ANYTHING YOU WANT ABOVE */\n// ==================\n\nfunction OnUpdate(doc, meta) {\n  try {\n    // Check if further analysis is needed we only trigger on an active recurring_event \n    if (doc.type !== \"recurring_event\" || doc.active !== true) return;\n\n    // On any mutation reset stats\n    doc.dynamic = {\n      \"state\": \"arm\",\n      \"next_sched\": 0,\n      \"prev_sched\": 0,\n      \"prev_etime\": 0,\n      \"prev_delay\": 0,\n      \"prev_atime\": 0,\n      \"total_runs\": 0\n    };\n\n    if (!doc.verbose) {\n      // Add if missing doc.dynamic with defaults\n      doc.verbose = {\n        \"user_func\": 1,\n        \"scheduler\": 1\n      };\n    }\n    if (!doc.dynamic || !doc.dynamic.state) return;\n\n    var mid = doc.type + \"::\" + doc.id; // this is the same as meta.id or the KEY\n    var hour = doc.hour;\n    var min = doc.min;\n\n    // Do an eval check the JavaScript function exists. The eval occurs in a common \n    // utility function shared with Callback\n    if (!verifyFunctionExistsViaEval(doc, mid)) {\n      // doc.action did not exist, we have already logged the issue\n      return;\n    }\n\n    // Get the next valid execution time\n    var date_timer = getNextRecurringDate(hour, min);\n    var next_sched = Math.round(date_timer.getTime() / 1000);\n    doc.dynamic.next_sched = next_sched;\n    try {\n      cron_bkt[mid] = doc;\n    } catch (e) {\n      log('OnUpdate help: F ' + mid + ' FATAL could not start KV cron cycle ' + doc.action);\n      return;\n    }\n\n    // Schedule an Eventing timer 6.6.0 uses mid (or meta.id) as the reference\n    var timer_id = createTimer(Callback, date_timer, mid, doc);\n    if (doc.verbose.scheduler >= 1) {\n      log('OnUpdate A ' + mid + ' rcv mutation (initial or rearm) schedule timer at ' +\n        toLocalISOTime(date_timer));\n    }\n    if (doc.verbose.scheduler >= 2) {\n      log('OnUpdate B ' + mid + ' first recurring timer was created, timer_id ' + timer_id);\n    }\n  } catch (e) {\n    log('OnUpdate E ' + meta.id + ', Error exception:', e);\n  }\n}\n\nfunction getNextRecurringDate(hour_str, min_str) {\n  // Note Javascript Dates are in milliseconds\n  var date_now = new Date();\n  var date_ret = new Date();\n  var hour;\n  var min;\n\n  try {\n    hour = parseInt(hour_str);\n  } catch (e) {}\n  try {\n    min = parseInt(min_str);\n  } catch (e) {}\n\n  // Note, this is only a simplistic partial 'crontab' syntax with some slight extensions\n  // it allows once a day, once an hour, once a minute.  It also contains some non-standard \n  // syntax to provide the ability to execute twice a minute or four times a minute.\n\n  if (hour_str === '*4X' && min_str === '*4X') {\n    // once every 15 seconds or four times a minute\n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(15);\n    while (date_ret.getTime() < date_now.getTime()) {\n      date_ret.setSeconds(date_ret.getSeconds() + 15);\n    }\n    return date_ret;\n  } else\n  if (hour_str === '*2X' && min_str === '*2X') {\n    // once every 30 seconds or twice a minute\n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(30);\n    while (date_ret.getTime() < date_now.getTime()) {\n      date_ret.setSeconds(date_ret.getSeconds() + 30);\n    }\n    return date_ret;\n  } else\n  if (hour_str === '*' && min_str === '*') {\n    // once a minute \n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(0);\n    date_ret.setMinutes(date_ret.getMinutes() + 1);\n  } else\n  if (hour_str !== '*' && isNaN(hour) === false && min_str === '*') {\n    // once a minute only for a given hour\n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(0);\n    date_ret.setMinutes(date_ret.getMinutes() + 1);\n    if (date_ret.getTime() < date_now.getTime()) {\n      date_ret.setHours(hour);\n    }\n    if (date_ret.getTime() > date_now.getTime()) {\n      date_ret.setDate(date_ret.getDate() + 1);\n      date_ret.setSeconds(0);\n      date_ret.setMinutes(0);\n      date_ret.setHours(hour);\n    }\n  } else\n  if (hour_str === '*' && min_str !== '*' && isNaN(min) === false) {\n    // once a hour at a given minute\n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(0);\n    date_ret.setMinutes(min);\n    // schedule for next hour\n    date_ret.setHours(date_ret.getHours() + 1);\n  } else\n  if (isNaN(hour) === false && isNaN(min) === false) {\n    // once a day for a given hour and a given minute \n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(0);\n    date_ret.setMinutes(min);\n    date_ret.setHours(hour);\n    if (date_ret.getTime() < date_now.getTime()) {\n      // schedule for tomorrow\n      date_ret.setDate(date_ret.getDate() + 1);\n    }\n  } else {\n    log('getNextRecurringDate illegal input hour_str <' +\n      hour_str + '> min_str <' + min_str + '>');\n    throw new Error('getNextRecurringDate illegal input hour_str <' +\n      hour_str + '> min_str <' + min_str + '>');\n    return null;\n  }\n  return date_ret;\n}\n\nfunction verifyFunctionExistsViaEval(curDoc, id) {\n  var result = false;\n  try {\n    // check for function if missing this is invalid return result\n    result = eval(\"typeof \" + curDoc.action + \" === 'function';\");\n    if (result === false) {\n      if (curDoc.verbose.scheduler >= 1)\n        log(\"Warn/Disable (No Action and No Re-Arm), because required 'action' of \" +\n          curDoc.action + \"(doc) does not exist, id is\", id);\n      return result;\n    }\n  } catch (e) {\n    log('verifyFunctionExistsViaEval Error exception:', e);\n  }\n  return result;\n}\n\nfunction toNumericFixed(number, precision) {\n  var multi = Math.pow(10, precision);\n  return Math.round((number * multi).toFixed(precision + 1)) / multi;\n}\n\nfunction toLocalISOTime(d) {\n  var tzoffset = (new Date()).getTimezoneOffset() * 60000; //offset in milliseconds\n  return (new Date(d.getTime() - tzoffset)).toISOString().slice(0, -1);\n}\n\nfunction Callback(doc) {\n  try {\n    var fired_at = new Date();\n\n    // Check if further analysis is needed we only trigger on a recurring_event that is active\n    if (doc.type !== \"recurring_event\") return;\n    // doc must have 'action', 'dynamic {}', verbose {}, dynamic.state\n    if (!doc.action || !doc.dynamic || !doc.verbose || !doc.dynamic.state) return;\n\n    // ==================\n    // Check if still active\n\n    // We make sure that in KV the 'doc' still exists and that it is still active if not just \n    // return thus skipping the action and not Re-arming the timer. Note `travel-sample` is \n    // aliased to the map 'cron_bkt\n\n    var mid = doc.type + '::' + doc.id; // make our KEY\n    var curDoc = null;\n    try {\n      // read the current version of doc from KV, e.g. curDoc\n      curDoc = cron_bkt[mid];\n    } catch (e) {} // needed for pre 6.5, note pure 6.5+ deployment returns null sans exception\n\n    var reason = null;\n    if (!curDoc || curDoc === null) {\n      reason = \"cron document is missing\";\n    } else\n    if (!curDoc.active) {\n      reason = \"cron document has active = false\";\n    } else\n    if (!curDoc.dynamic.state || curDoc.dynamic.state !== doc.dynamic.state) {\n      reason = \"cron document wrong dynamic.state expected \" + doc.dynamic.state;\n    } else\n    if (crc64(doc) !== crc64(curDoc)) {\n      reason = \"cron document changed\";\n    }\n\n    if (reason !== null) {\n      if (!curDoc || curDoc === null || curDoc.verbose.scheduler >= 1) {\n        log('Callback X ' + mid + \" ignore/stop this timer's schedule because \" + reason);\n      }\n      if (!curDoc || curDoc === null || curDoc.verbose.scheduler >= 4) {\n        log('Callback Y ' + mid + ' timer doc', doc);\n        log('Callback Z ' + mid + ' KV curDoc', curDoc);\n      }\n      return;\n    }\n\n    // ==================\n    // Verify user routine exists and if so eval it \n\n    // Assume curDoc.action contains something like \"doCronActionA\" and we have a function in \n    // this handler like \"doCronActionA(doc)\". Below we use curDoc as the end user should be \n    // able to alter the eval'd JavaScript function.  We will execute two (2) evals.\n\n    // First eval check the JavaScript function exists.  The eval occurs in a common \n    // utility function shared with Callback\n    if (!verifyFunctionExistsViaEval(curDoc, mid)) {\n      // curDoc.action did not exist, we have already logged the issue\n      return;\n    }\n\n    // Second eval execute and process the user function we execute the defined function \n    // with an argument of curDoc\n    var beg_act = new Date();\n    var result = null;\n    eval(\"result = \" + curDoc.action + \"(curDoc);\");\n    var end_act = new Date();\n    var atime_ms = end_act.getTime() - beg_act.getTime();\n    curDoc.dynamic.total_runs++;\n\n    if (curDoc.verbose.scheduler >= 2)\n      log('Callback R ' + mid + ' action took ' + toNumericFixed((atime_ms / 1000), 3) +\n        ' sec., run_number '+ curDoc.dynamic.total_runs +\n        ', returned ' + result);\n\n    // ==================\n    // Calculate next time and update the control document then create or re-arm \n    // our another timer with a mid (or meta.id) reference.\n\n    var hour = curDoc.hour;\n    var min = curDoc.min;\n    var date_timer = getNextRecurringDate(hour, min);\n\n    curDoc.dynamic.prev_delay =\n      toNumericFixed(((fired_at.getTime() / 1000) - curDoc.dynamic.next_sched), 3);\n    curDoc.dynamic.prev_sched = curDoc.dynamic.next_sched;\n    curDoc.dynamic.prev_etime = Math.round(fired_at.getTime() / 1000);\n    curDoc.dynamic.prev_atime = toNumericFixed((atime_ms / 1000), 3);\n\n    curDoc.dynamic.state = \"rearm\";\n    curDoc.dynamic.next_sched = Math.round(date_timer.getTime() / 1000);\n    \n    try {\n      cron_bkt[mid] = curDoc;\n    } catch (e) {\n      log('Callback help: F ' + mid + ' FATAL could not update KV cron cycle ' + curDoc.action);\n      return;\n    }\n\n    if (curDoc.verbose.scheduler >= 1) {\n      log('Callback A ' + mid + ' next schedule rearm at ' +\n        toLocalISOTime(date_timer));\n    }\n    if (curDoc.verbose.scheduler >= 2) {\n      log('Callback B ' + mid + ' sched ' + curDoc.dynamic.prev_sched +\n        ', actual ' + curDoc.dynamic.prev_etime +\n        ', delay ' + curDoc.dynamic.prev_delay +\n        ', took ' + curDoc.dynamic.prev_atime);\n    }\n    if (curDoc.verbose.scheduler >= 3) {\n      log('Callback C ' + mid + ' curDoc', curDoc);\n    }\n    \n    // Re-Schedule an Eventing timer 6.6.0 uses mid (or meta.id) as the reference\n    // and can schedule an timer form a timer callback\n    var timer_id = createTimer(Callback, date_timer, mid, curDoc);\n    if (doc.verbose.scheduler >= 1) {\n      log('Callback D ' + mid + ' (rearm) schedule timer at ' +\n        toLocalISOTime(date_timer));\n    }\n    if (doc.verbose.scheduler >= 2) {\n      log('Callback G ' + mid + ' another recurring timer was created, timer_id ' + timer_id);\n    }\n  } catch (e) {\n    var mid = doc.type + '::' + doc.id; // make our KEY\n    log('Callback E ' + mid + ' Error exception:', e);\n  }\n}","depcfg":{"buckets":[{"alias":"cron_bkt","bucket_name":"crondata","access":"rw"},{"alias":"ts_bkt","bucket_name":"travel-sample","access":"rw"}],"curl":[],"metadata_bucket":"metadata","source_bucket":"crondata"},"version":"evt-6.5.1-0000-ee","handleruuid":1588915366,"id":0,"function_instance_id":"NQmPl","appname":"cron_impl_1func_660","settings":{"cluster_stats":null,"dcp_stream_boundary":"from_now","deadline_timeout":62,"deployment_status":false,"description":"A cron like scheduler part 1 (6.6.0) single function version","execution_timeout":60,"language_compatibility":"6.5.0","log_level":"INFO","n1ql_consistency":"none","processing_status":false,"user_prefix":"eventing","using_timer":true,"worker_count":3},"using_timer":true,"src_mutation":true}]