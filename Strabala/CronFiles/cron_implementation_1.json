[{"appcode":"/* \nCreate a basic cron system using Eventing allows a recurring function to execute activity\na specified tie every day.  We used the 'travel-sample' and placed a control document \nof type == \"recurring_event\" for this example.  Note for testing uncomment out the line \nafter TEST_ONLY.  Important you will need to alias 'travel-sample'  to 'ts' when you add \nthis function into Eventing.\n\nTest Doc: \n   {\n        \"type\":\"recurring_event\",   // The KEY will be <<type>>::<<id>>\n        \"id\":1,                     // \n        \"hour\":14,                  // The hour of the day 0-23, *, *2X, *4X to trigger\n        \"min\":54,                   // The minute in the hour 0-59, *, *2X, *4X to trigger\n        \"action\":\"doCronActionA\",   // What function to run on the trigger\n        \"verbose\":2,                // Logging level: 0=none, 1 or 2=action, 3=lots\n        \"active\":false              // Flag to arm or disable this schedule\n    } \n    \n    INSERT INTO `travel-sample` (KEY,VALUE) VALUES (\"recurring_event::1\", \n    {\n        \"type\":\"recurring_event\",\n        \"id\":1,\n        \"hour\":14,\n        \"min\":54,\n        \"action\":\"doCronActionA\",\n        \"verbose\":2,\n        \"active\":false\n    } \n);\n\nN1QL : Verify or inspect settings in schedule\t        \n    SELECT * FROM `travel-sample` WHERE type=\"recurring_event\";\n\nN1QL : Arm or set active\t    \n    UPDATE `travel-sample` SET active = true WHERE type=\"recurring_event\" AND id=1 ;\n    \nN1QL : Disarm or set inactive\t\n    UPDATE `travel-sample` SET active = false WHERE type=\"recurring_event\" AND id=1 ;\n    \nN1QL : Adjust time of trigger\t\n    UPDATE `travel-sample` SET hour = 11 AND min = 30 WHERE type=\"recurring_event\" AND id=1 ;\n\nN1QL : Adjust logging\t        \n    UPDATE `travel-sample` SET logging = 0 WHERE type=\"recurring_event\" AND id=1 ;\n\nN1QL : Delete the schedule\t    \n    DELETE FROM `travel-sample` WHERE type=\"recurring_event\" AND id=1 ;\n         \nThe action is important it 'should' exist in this Eventing Function if could be any \nJavascript name e.g. MyFunc and you must implement is as say doCronActionA(doc) where doc \nwill be the currently active item of type = 'recurring_event' read from the source bucket\nwhen the timer is fired.  This should return  true or false used for loggin purposes.  If\nthe action does not exist it is an error and a warning is logged and the timer is disabled.\n\nIn 6.5+ add a new cron like daily function just pause the active handler insert your new \nfunction doCronActionB(doc) {...} then Resume the eventing handler.  The nice thing is if\na time was to be fired will the fucntion was paused it will NOT be lost, when you resume \nthe function it will be processed.\n*/\n\n// ==================\n/* BEG USER FUNCTIONS TO RUN ONCE A DAY, HOUR, OR MINUTE - ANYTHING YOU WANT BELOW */\nfunction doCronActionA(doc) {\n  // check that doc has desired values\n  if (doc.type !== \"recurring_event\" || doc.active != true) return;\n  if (doc.verbose >= 1)\n    log(doc.action + ' user action controlled by ', doc.type + '::' + doc.id);\n  // this is a 6.5 N1QL query (feature not available prior to 6.5)\n  try {\n    // Create an embedded N1QL iterator by issuing a SELECT statement to get the\n    // counts of airlines by country.  Make a new document and write it out to KV \n\n    // We will use the iterator to create a KV document representing the results of a\n    // HARD lengthy embedded N1QL query and write it back to KV, the idea is to keep\n    // a calculation up to date once a day such that it that can be read 'quickly' \n    // by other Eventing Functions, other Couchbase services or SDKs.   \n\n    // Consider if we had 1 million docs in a minute do we really want to use N1QL\n    // to recalculate something that is almost static for all 1 million documents, of \n    // course not, so we make an intermediate value that can be read into Eventing\n    // and used via a single 'light weight' KV read.\n\n    var q_iter = SELECT country,\n      count( * ) cnt\n    FROM `travel-sample`\n    WHERE `type` = 'airline'\n    GROUP BY country;\n\n    // loop through the result set and update the map 'accumulate'\n    var accumulate = {};\n    var idx = 0;\n    for (var val of q_iter) {\n      if (doc.verbose >= 2)\n        log(doc.action + ' N1QL idx ' + idx + ', country ' + val.country + \" cnt \" + val.cnt);\n      accumulate[val.country] = val.cnt;\n      idx++;\n    }\n    // close out embedded N1QL iterator\n    q_iter.close();\n\n    // Now letâ€™s make a cached KV document representing a HARD length embedded N1QL\n    // query and write it back to KV, we need a KEY and a type and id and then we \n    // upsert it into the `travel-sample` bucket.\n\n    var cachedoc = {};\n    cachedoc.type = \"cron_cache\";\n    cachedoc.id = \"airlines_by_country\";\n    cachedoc.date = new Date();\n    cachedoc.data = accumulate;\n    var ckey = cachedoc.type + '::' + cachedoc.id;\n    ts[ckey] = cachedoc;\n    if (doc.verbose >= 2) {\n      log(doc.action + ' upsert to KV with KEY ' + ckey + ' cachedoc ', cachedoc);\n    }\n  } catch (e) {\n    log(doc.action + ' Error exception NIQL:', e);\n    return false;\n  }\n  return true;\n}\n\nfunction doCronActionB(doc) {\n  // check that doc has desired values\n  if (doc.type !== \"recurring_event\" || doc.active != true) return;\n  if (doc.verbose >= 1)\n    log(doc.action + ' user action controlled by ', doc.type + '::' + doc.id);\n\n  // YOUR LOGIC HERE\n\n  return true;\n}\n\nfunction doCronActionC(doc) {\n  // check that doc has desired values\n  if (doc.type !== \"recurring_event\" || doc.active != true) return;\n  if (doc.verbose >= 1)\n    log(doc.action + ' user action controlled by ', doc.type + '::' + doc.id);\n\n  // YOUR LOGIC HERE\n\n  return true;\n}\n\n/* END USER FUNCTIONS TO RUN ONCE A DAY, HOUR, OR MINUTE - ANYTHING YOU WANT ABOVE */\n// ==================\n\nfunction OnUpdate(doc, meta) {\n  // Check if further analysis is needed we only trigger on an active recurring_event \n  if (doc.type !== \"recurring_event\" || doc.active != true) return;\n  // log(\"SETUP id \" + doc.id + \" type \" + doc.type + \" active \" , doc.active);\n\n  var id = doc.type + \"::\" + doc.id; // this is the same as meta.id or the KEY\n  var hour = doc.hour;\n  var min = doc.min;\n\n  // Do an eval check the JavaScript function exists. The eval occurs in a common \n  // utility function shared with RecurringCallback\n  if (!verifyFunctionExistsViaEval(doc, id)) {\n    // doc.action did not exist, we have already logged the issue\n    return;\n  }\n\n  // Get the next valid execution time\n  var date_timer = getNextRecurringDate(hour, min);\n  if (doc.verbose >= 3) {\n    log(\"OnUpdate (sched date) \" + date_timer);\n    log('OnUpdate create recurring timer for id ', id);\n  }\n\n  // Schedule an Eventing timer\n  createTimer(RecurringCallback, date_timer, id, doc);\n}\n\nfunction getNextRecurringDate(hour_str, min_str) {\n\n  // Note Javascript Dates are in milliseconds\n  var date_now = new Date();\n  var date_ret = new Date();\n\n  var hour;\n  var min;\n  try {\n    hour = parseInt(hour_str);\n  } catch (e) {}\n  try {\n    min = parseInt(min_str);\n  } catch (e) {}\n\n  // Note, this is only a simplistic partial 'crontab' syntax with some slight extensions\n  // it allows once a day, once an hour, once a minute.  It also contains some non-standard \n  // syntax to provide the ability to execute twice a minute or four times a minute.\n\n  if (hour_str === '*4X' && min_str === '*4X') {\n    // once every 15 seconds or four times a minute\n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(15);\n    while (date_ret.getTime() < date_now.getTime()) {\n      date_ret.setSeconds(date_ret.getSeconds() + 15);\n    }\n    return date_ret;\n  } else\n  if (hour_str === '*2X' && min_str === '*2X') {\n    // once every 30 seconds or twice a minute\n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(30);\n    while (date_ret.getTime() < date_now.getTime()) {\n      date_ret.setSeconds(date_ret.getSeconds() + 30);\n    }\n    return date_ret;\n  } else\n  if (hour_str === '*' && min_str === '*') {\n    // once a minute \n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(0);\n    date_ret.setMinutes(date_ret.getMinutes() + 1);\n  } else\n  if (hour_str !== '*' && isNaN(hour) == false && min_str === '*') {\n    // once a minute only for a given hour\n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(0);\n    date_ret.setMinutes(date_ret.getMinutes() + 1);\n    if (date_ret.getTime() < date_now.getTime()) {\n      date_ret.setHours(hour);\n    }\n    if (date_ret.getTime() > date_now.getTime()) {\n      date_ret.setDate(date_ret.getDate() + 1);\n      date_ret.setSeconds(0);\n      date_ret.setMinutes(0);\n      date_ret.setHours(hour);\n    }\n  } else\n  if (hour_str === '*' && min_str !== '*' && isNaN(min) == false) {\n    // once a hour at a given minute\n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(0);\n    date_ret.setMinutes(min);\n    // schedule for next hour\n    date_ret.setHours(date_ret.getHours() + 1);\n  } else\n  if (isNaN(hour) == false && isNaN(min) == false) {\n    // once a day for a given hour and a given minute \n    date_ret.setMilliseconds(0);\n    date_ret.setSeconds(0);\n    date_ret.setMinutes(min);\n    date_ret.setHours(hour);\n    if (date_ret.getTime() < date_now.getTime()) {\n      // schedule for tommorow\n      date_ret.setDate(date_ret.getDate() + 1);\n    }\n  } else {\n    log('getNextRecurringDate illegal input hour_str <' + hour_str + '> min_str <' + min_str + '>');\n    throw new Error('getNextRecurringDate illegal input hour_str <' + hour_str + '> min_str <' + min_str + '>');\n    return null;\n  }\n\n  // Most likely redundent, note we don't apply this to '*4X' or '*2X' \n  if ((date_ret.getTime() + (1 * 5 * 1000)) < date_now.getTime()) {\n    // schedule for 5 seconds in the future \n    date_ret.setTime(date_now.getTime() + 5);\n  }\n\n  return date_ret;\n}\n\nfunction verifyFunctionExistsViaEval(curDoc, id) {\n  var result = null;\n  // check for function if missing this is invalid return result\n  result = eval(\"typeof \" + curDoc.action + \" === 'function';\");\n  if (result == false) {\n    if (curDoc.verbose >= 3)\n      log(\"Warn/Disable (No Action and No Re-Arm), because required 'action' of \" +\n        curDoc.action + \"(doc) does not exist, id is\", id);\n    return result;\n  }\n  return result;\n}\n\nfunction RecurringCallback(doc) {\n  // Check if further analysis is needed we only trigger on a recurring_event that is active\n  if (doc.type !== \"recurring_event\") return;\n  if (!doc.action) return;\n\n  // ==================\n  // Check if still active\n\n  // We make sure that in KV the 'doc' still exists and that it is still active if not just \n  // return thus skipping the action and not Re-arming the timer. Note `travel-sample` is \n  // aliased to the map 'ts'\n  var id = doc.type + \"::\" + doc.id;\n  var curDoc = null;\n  try {\n    // read the current version of doc from KV, e.g. curDoc\n    curDoc = ts[id];\n  } catch (e) {} // needed for pre 6.5, note pure 6.5+ deployment returns null sans exception\n  if (!curDoc) {\n    if (doc.verbose >= 3)\n      log(\"Disable (No Action and No Re-Arm), because src document controlling \" +\n        \"recurring timer missing, id was\", id);\n    return; // will work for pre 6.5 and post 6.5+ logic\n  }\n  // look at the current doc, not the context we have been passing around to Re-arm\n  if (curDoc.active != true) {\n    if (curDoc.verbose >= 3)\n      log(\"Disable (No Action and No Re-Arm), because src document controlling \" +\n        \"recurring timer has 'active' = false, id is\", id);\n    return;\n  }\n\n  // ==================\n  // Verify user routine exists and if so eval it \n\n  // Assume curDoc.action contains something like \"doCronActionA\" and we have a function in \n  // this handler like \"doCronActionA(doc)\". Below we use curDoc as the end user should be \n  // able to alter the eval'd JavaScript function.  We will execute two (2) evals.\n\n  // First eval check the JavaScript function exists.  The eval occurs in a common \n  // utility function shared with RecurringCallback\n  if (!verifyFunctionExistsViaEval(curDoc, id)) {\n    // curDoc.action did not exist, we have already logged the issue\n    return;\n  }\n\n  // Second eval execute and process the user function we execute the defined function \n  // with an argument of curDoc\n  var result = null;\n  eval(\"result = \" + curDoc.action + \"(curDoc);\");\n  if (curDoc.verbose >= 3)\n    log(\"action for \" + id + \" executed and it returned\", result);\n\n  // ==================\n  // Re-Arm the timer\n\n  var hour = doc.hour;\n  var min = doc.min;\n\n  var date_timer = getNextRecurringDate(hour, min);\n  if (curDoc.verbose >= 3) {\n    log(\"RecurringCallback (sched date) \" + date_timer);\n    log('RecurringCallback create recurring timer for id ', id);\n  }\n\n  // Re-arm e.g. Re-schedule an Eventing timer\n  createTimer(RecurringCallback, date_timer, id, curDoc);\n}","depcfg":{"buckets":[{"alias":"ts","bucket_name":"travel-sample","access":"rw"}],"curl":[],"metadata_bucket":"metadata","source_bucket":"travel-sample"},"version":"evt-6.5.0-4469-ee","handleruuid":2468467935,"id":0,"function_instance_id":"qOAtY","appname":"cron_implementation_1","settings":{"agg_dcp_feed_mem_cap":1024,"app_log_max_files":10,"app_log_max_size":41943040,"breakpad_on":true,"checkpoint_interval":60000,"cleanup_timers":false,"cluster_stats":null,"cpp_worker_thread_count":2,"data_chan_size":50,"dcp_gen_chan_size":10000,"dcp_num_connections":1,"dcp_stream_boundary":"everything","deadline_timeout":62,"deployment_status":false,"description":"","enable_applog_rotation":true,"execute_timer_routine_count":3,"execution_timeout":60,"feedback_batch_size":100,"feedback_read_buffer_size":65536,"idle_checkpoint_interval":30000,"language_compatibility":"6.5.0","lcb_inst_capacity":5,"log_level":"INFO","n1ql_consistency":"none","poll_bucket_interval":10,"processing_status":false,"sock_batch_size":100,"tick_duration":60000,"timer_context_size":1024,"timer_queue_mem_cap":50,"timer_queue_size":10000,"timer_storage_chan_size":10000,"timer_storage_routine_count":3,"undeploy_routine_count":6,"user_prefix":"eventing","using_timer":true,"vb_ownership_giveup_routine_count":3,"vb_ownership_takeover_routine_count":3,"worker_count":3,"worker_feedback_queue_cap":500,"worker_queue_cap":100000,"worker_queue_mem_cap":1024,"worker_response_timeout":3600},"using_timer":false,"src_mutation":true}]